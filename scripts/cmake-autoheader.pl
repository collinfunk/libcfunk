#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;;

my $cache_file = '';
my $config_file = '';
my @defines = ();

sub emit_usage ()
{
  print <<EOF
  This file is run internally at the end of the build process by CMake.
  It should not be used manually. It reads the CMake Cache file and finds
  all variables with the `HAVE_' prefix and places them in a header. This
  makes sure that only symbols and headers that are checked are defined.

  It is invoked like so in `libcfunk-final.cmake':
    cmake-autoheader.pl cache-file config-header
EOF
    ;
  exit (1);
}

sub get_cache_vars ($)
{
  my ($file_name) = @_;
  my $file_handler;

  open ($file_handler, "<", $file_name) or
    die "Could not open cache file `$file_name': $!.\n";

  foreach (<$file_handler>)
    {
      chomp;
      if ($_ =~ /(HAVE_[\w]+):(?:\w+)=(?:(\w+))?/)
        {
          my $name = $1;
          my $value = defined ($2) ? $2 : "0";
          push (@defines, "#define $name $value");
        }
    }

  close ($file_handler);
}

sub write_config ($)
{
  my ($file_name) = @_;
  my $file_handler;

  open ($file_handler, ">", $file_name) or
    die "Could not open config file `$file_name': $!.\n";

  print ($file_handler "/* Autogenerated, do not edit. */\n\n");
  print ($file_handler "#ifndef CONFIG_H\n#define CONFIG_H\n\n");
  print ($file_handler join ("\n", @defines) . "\n\n");
  print ($file_handler "#endif /* CONFIG_H */\n\n");

  close ($file_handler);
}

if (scalar @ARGV < 2)
  {
    emit_usage ();
  }

$cache_file = $ARGV[0];
$config_file = $ARGV[1];

die ("Cache file `$cache_file' does not exist.\n") if
  ! -f $cache_file ;

get_cache_vars ($cache_file);
write_config ($config_file);
